# c 语言字符数组需要结束标志 '\0' 吗

[TOC]

## 问题提出背景

现有需求：需要从给定字符数组中提取内容，内容长度不固定（但是可通过判断结束标志，结束提取内容）。
就是说，我需要定义一个新的数组接收提取的内容，这个接收数组的长度肯定是比给定数组的长度小。这个新的数组的长度定义多少才合适？然后这个数组可以输出准确吗？

简化需求：从给定的字符数组提取前两位，也就是说内容长度固定。从而确定接收数组的长度定义多少合适！

## 基础知识

字符数组初始化的问题：

```c
char a = 0;
char b = '0';
char c = '\0';
/**
1. 两者区别：（0 的 ASCII 值是 48）
  a 的值实际上是 0
  b 的值实际上是 48
  c 的值实际上是 0
2. 总结：
  字符直接赋值 的作用是  把该值原封不动赋给变量。
  字符用 '' 赋值的作用是 把 '' 的内容转换为 ASCII 值再赋值给变量。（意思就是，根据 '' 里面的内容在 ASCII 表上找到一样的字符，看看它对应的十进制，然后赋值给变量）
 */
```

## 情景一：定义字符数组时进行初始化

### 接收数组长度 > 内容长度

```c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    char a[] = "1a3b"; // 给定数组
    char b[3] = { 0 }; // 接收数组

    int i = 0;
    for (i = 0; i < 2; i++)
    {
        b[i] = a[i];
    }
    printf("%s", b);
    return 0;
}
```

* 输出结果：1a
* 说明：
  
  * 给定数组 在初始化时，系统在最后加上 `\0`。所以内存占了 5 个字节（`char` 定义的变量占一个字节）。但是有效长度是 4 ，因为遇到 `\0` 就停止。
  * 接收数组 在初始化时，数组的值全为 0。
  * 拓展：接收数组不一定初始化为 `0` ，实测，`char b[3]={1};` 时，第一位值为 1，后面的值都是 0 。也就是说，只要初始化了就没问题。

### 接收长度 = 内容长度

```c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    char a[] = "1a3b"; // 给定数组
    char b[2] = { 0 }; // 接收数组

    int i = 0;
    for (i = 0; i < 2; i++)
    {
        b[i] = a[i];
    }
    printf("%s", b);
    return 0;
}
```

* 输出结果：1a烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫
* 说明：
  * 程序出错是因为接收数组的长度 等于 内容长度后，接收数组在内存中后一个值不确定了，如果刚好是字符 `'\0'`（也就是值为 `0` ），程序输出就没问题。

## 情景二：定义字符数组时不进行初始化

这种情况和上面的情景的区别就是，一开始字符数组的值不确定。所以在赋值完后，必须手动在末尾加上 `'\0'`。

## 总结

无论定义数组时初不初始化，接收数组的长度都要比内容长度大。

* 如果已知内容长度
  接收数组的长度都要比内容长度大。提取内容（赋值）完后，可以不用在有效长度的基础上加上 `\0`。但建议加上，养成良好的习惯。

* 在内容长度不确定时
  接收数组长度在定义时就要大一些。提取内容（赋值）完后，必须在有效长度的基础上加上 `\0`。

* 总的来说就是，接收数组要大，结束后加上 `\0`。准没错。
