# PKI

[TOC]

## 一、概述

1. PKI概述

    * 名称：Pubilc Key Infrastructures 公钥基础设施。
    * 作用：通过加密技术和数字签名保证信息的安全。（PKI 要做的就是确保信息安全的三要素）
    * 组成：公钥加密技术、数字证书、CA、RA

2. 信息安全三要素

    * **机密性**：就是我发信息给你，这个信息不管别人收没收到，别人都不能知道信息的内容，防止数据被泄密。（即加密，保证别人看不懂）
    * **完整性**：保证数据不能被破坏。（意思实际上是：（信息被破坏 PKI 是保证不了的）所以保证的是信息被破坏后，接收端知道信息被人篡改了，不能收，再通知我发一遍）
    * **身份验证/操作的不可否认性**：身份验证指的是：别人冒充我发信息，你收到了你要看看是不是我发的。操作的不可否认性值得是：我再检查了这个信息就是你发的情况下然后解开信息了，结果是病毒。那么这个病毒就是你发的，你也不用否认。（总的来说就是：别人冒充你，我能查出来；如果是你发的，你也不要否认。）

3. 哪些 IT 领域用到 PKI:

    * SSL/HTTPS
    * IPsecVPN
    * 部分远程访问 VPN

4. 公钥加密技术

    * 作用：实现对信息加密、数字签名等安全保障。
    * 加密算法（算法是公开的）：

        (1) 对称加密算法（DES, 3DES, AES）
        * 即：加解密的密钥一致。（如以下的密钥5，加密用它，解密也是用它）
        * 例如： `x+5=y`
          `x` 是原数据/原文
          `y` 是密文
          `5` 是 Key/密钥

        (2) 非对称加密算法（RSA,DH）
        * 通信双方各自产生一对公私钥。
        * 双方各自交换公钥。
        * 公钥和私钥为互相加解密关系。
        * 公私钥不可互相逆推。

5. HASH 算法

    * 作用：验证完整性的算法。把内容转换成 HASN 值。
    * 类型：MD5, SHA
    * 说明：HASH 值不可逆。因为 HASH 把内容转换成 HASH 值，所以相当于内容的**摘要**。

6. 数字签名

    用自己的私钥对 摘要 加密得出的 密文 就是数字签名（就是对 HASH 用自己的私钥进行加密）
    * 作用：就是保证 HASH 无法被 HACKER 重新计算，因为是用 发送方的私钥 加密，没有人有这个私钥。

7. 证书

    * 作用：用于保证公密的合法性。
    * 证书格式遵循X.509标准
    * 数字证书包含信息：
        * 使用者的公钥值
        * 使用者标识信息（如名称和电子邮件地址）
        * 有效期（证书的有效时间）
        * 颁发者标识信息
        * 颁发者的数字签名
    * 数字证书由权威公正的第三方机构即CA签发

8. CA
   * 是权威证书颁发机构，为了公正“公钥”的合法性！
机密性：使用对方的公钥加密！
身份验证/数字签名：使用自己的私钥
   * 目的：给公钥颁发证书，公正公钥的合法性。

## 二、流程

**约定：**

* 首先，A、B双方都各自生成公私钥，A 是发送端，B是接收端。
* CA 有自己的公私钥。

**思考：**

1. 如何保证数据的**机密性**？

    * 假设1：A 用 A 的私钥加密数据。
    结果1：大家都有 A 的公钥，大家都可以解密数据。假设不成立。
    * 假设2：A 用 **B 的公钥**加密数据。（正确）
    结果2：因为别人没有 B 的私钥，截取了信息也解密不了！

2. 如何确保数据的**完整性**?

    通过**计算加密后的数据** HASH 值进行验证。(为什么要加密后的数据？这样接收端就不用解密数据再验证 HASH)

3. 如何确认数据是 A 发送的？（**身份验证**）

    * 假设1：A 用 B 的公钥对数据签名。
    结果1：B 用自己的私钥解密签名，可以解开。但是怎么能保证数据是 A 发的？因为公钥大家都是知道的，人人都可以用 B 的公钥对数据签名。所以假设不成立。
    * 假设2：A 用 **A 的私钥**对数据签名（正确）
    结果2：B 用 A 的公钥解密，可以解开。那么该数据就是 A 发送的。因为 A 的私钥只有它自己有。别人伪造不了。所以假设成立。

    结论：A 用 **A 的私钥**签名，B 用 A 的公钥解密。

**小结：**

1. A 用 B 的公钥加密数据，后用 A 的私钥对数据进行签名。保证了数据的机密性和身份验证。
2. 用对方的公钥加密，是为了机密性。
3. 用自己的私钥签名，是为了身份验证。

![看不到图是科学问题](https://raw.githubusercontent.com/yiyah/Picture_Material/master/20210907233014.png)
### 情景一：A、B通信

`step1`: A、B 双方交换各自的公钥
`step2`: A 用 B 的公钥加密数据，后用 A 的私钥对数据进行签名，把数据发给 B 。
`step3`: B 用 A 的公钥验证签名，验证成功，就是A发的，再解密数据。

**问题：**

* B 再能用 A 的公钥成功验证签名的时候，就已经确定数据是 A 发的。但是，如果在 `step1`  中，H 截获了该过程，并把 H 自己的公钥发给 B , 那么以后 H 跟 B 的通信，B 都是认为自己在跟 A 通信，并且因为**操作的不可否认性**，B 认为该数据就是 A 发送的。

  也就是说，在 `step1` 中，B 怎么确认收到的公钥就是 A 的？（看情景2）

### 情景二：A、B通信 + CA

`step1`: A 到 CA 注册证书，把自己的**公钥**、姓名、网址、国家、手机号码、邮箱等信息发给 CA。（为了能让 B 知道收到的公钥是假的，B 要把自己的公钥发给 CA。就是
把自己的公钥拿去公证一下）
`step2`: CA 收到 A 的注册申请后，审核验证。然后，给 A 颁发一个证书。**这个证书重要的是用 CA 的私钥进行签名**。
`step3`: A、B 双方交换各自的公钥（A 发给 B 的公钥含有证书）。

**问题：**

* B 怎么确认收到的公钥就是 A 的？总不能你说这个公钥是就是吧？？
  所以，这次 A 发给的 B 的公钥里包含了一个证书。B 用 CA 的公钥验证证书，再解开证书数据，对比证书的公钥和收到的公钥是否一致。
  那么这一步的关键就是 B 要对 CA 的信任问题！（B信任CA后就得到CA 的公钥了）
  否则，H 自己搭建一个 CA ，然后自己给自己颁发证书。继续 `step3`，如果 B 对 H 的 CA 也信任的话，该通信还是被 H 监听了。
  如果 B 对 CA 不信任，B 也就没有 CA 的公钥，证书验证不了，通信也建立不起来。

**小结：**

* 通过情景1和2，可以得出，A、B 双方要建立安全的通信，必须要有一个大家都信任的第三方 CA。A 到 CA 申请证书，B 用 CA 的公钥验证证书，对比收到的公钥是否一致。

* 如果只有 A 和 B 通信（无 H ），不用 CA 就已经很安全了。

### 最终完成流程

* Notes：情景一和二是为了说明怎么确保在一开始交换的公钥的合法性。接下来的步骤是在已经交换了公钥的情况下进行的，也就是说 B 已经完全信任收到的公钥就是 A 的。

**A 的步骤：**

`step1`: 把数据和对方的公钥放到 RSA 算法加密（**机密性**）
`step2`: 根据 `step1` 的数据计算 HASH 值（**完整性**）
`step3`: 把 HASH 值和自己的私钥放到 RSA 算法加密（**身份验证**）
`step4`: `step1` 和 `step2` 的数据拼接
`step5`: 发送

**B 的步骤：**

`step1`: 把收到的数据拆开两部分，一为加密的数据，二为加密的 HASH
`step2`: 用对方的公钥解开加密的 HASH，如果解开了，就代表一定是 A 发的。（**身份验证**）
`step3`: 计算加密的数据的 HASH 值，对比解密的 HASH 值是否一致。（**完整性**）
`step4`: 用自己的私钥解开数据。（**机密性**）
