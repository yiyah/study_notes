# 键盘处理中断

[toc]

## Pre-learning

* 在发生键盘中断的时候，我们都是用 BIOS 提供的 int 9 中断进行处理的。键盘的数据放在 BIOS键盘缓冲区里，大小是15个字形数据。
* 在 int 9 中断里，也是通过读取 60H 端口来读取键盘的输入的。（这时候想想，之前我们是通过把原本的int9中断程序的地址保存起来，然后把自己实现的int9程序的地址放到向量表中，自己实现的中断里还是调用了原来的int9的程序来读取键盘数据，也就是函数调用顺序是：自己实现的中断 -->原本的中断 -->得到键盘数据（即 new int9 --> old int9 --> int16）。说这个是因为想要表明 **原本的 int9 就是把键盘数据写到 BIOS键盘缓冲区里，然后自己通过端口读取缓冲区的键盘数据**）
* 示例：
    按下 'a'，60H 端口就会出现数据（我们知道这个 BIOS键盘缓冲区 里是字型数据，那么就会有高低位之分，所以：**高8位保存扫描码，低8位保存ASCII码**）：1E61H（扫描码：1E，ASCII码：61Hs）（所以呢，这个数据出现在 BIOS键盘缓冲区 是谁做的？是 int9）

那么问题来了，我们可不可以读取 BIOS键盘缓冲区 的内容呢？端口不就行了吗？不行，因为端口读取的是扫描码！
所以 BIOS 给我们提供了 int 16H 中断，用来访问 这个键盘缓冲区的内容。怎么用呢？如下：

    ```asm
    mov     ah,0        ; 相当于 功能号
    int     16H
    ; 调用完之后数据放到 AX 中
    ; AH = 扫描码       AL = ASCII
    ```

* 关于 int 16H 的执行过程

    它从 键盘缓冲区 里读取数据出来 后 删掉。
    那这 15 个字型数据填满以后会怎么样？会报警（蜂鸣器），会覆盖数据（具体就不清楚）

* int 16H 的总结

    所以这个中断干了些什么事情呢？
    1. 检测键盘缓冲区 是否 有数据
    2. 没有的话继续检测
    3. 读取缓冲区第一个字型数据 的键盘输入
    4. AH = 高位，AL = 低位
    5. 删除 读取的字型数据
