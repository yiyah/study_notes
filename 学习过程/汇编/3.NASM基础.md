# NASM 基础

1. `org`
    ORG 是 Origin 的缩写：起始地址源。在汇编语言源程序的开始通常都用一条 ORG 伪指令 来实现规定程序的起始地址。如果不用ORG规定则汇编得到的目标程序将从0000H开始。
    ORG，在汇编语言中也是一条指令，其作用是告诉汇编程序，在开始执行的时候，将某段机器语言装载到内存中的哪个地址。
    **org 07C00H 后，编译器计算地址会从0x7C00 开始**

2. 符号命名规则以及立即数的表示形式、越界问题：

    1) 对于指令、寄存器名称以及立即数中的字母，都对大小写不敏感；

    2) 但是对于标号是大小写敏感的！比如Tag:和tag:就是两个完全不同的标号；

    3) 标号必须以字母开头，或者是以'_'、'.'、'@'、'?'开头，当然标号当中也可以包含这些符号，并且标号也可以只包含这些符号，比如'@@'等，但是如果以特殊符号开头而不是以字母开头，对于NASM有特殊含义（之后会详细讲解）；

    4) 立即数的表示：

        i. 规则基本和MASM一样，可以用H、没有后缀、B来区分十六进制、十进制、二进制，并且后缀的大小写随意；

        ii. 后缀法表示十六进制时，如果是以字母开头的就必须加一个0前缀，否则编译器会认为这是一个标号而不是一个立即数而报错！（注意：标号基本上是以字母开头的）

        iii. 但是NASM还支持更加传统的十六进制表示形式，就是C语言的0x前缀表示法，用这种方式十六进制如果是以字母开头就无需加0前缀了，并且无需任何后缀，x的大小写随意；

3. nasm 中文手册
    * 在【3.8 临界表达式】 中，有如下说明：
    NASM 的一个限制是它是一个两遍的汇编器；不像 TASM 和其它汇编器，它总是只做两遍汇编。所以它就不能处理那些非常复杂的需要三遍甚至更多遍汇编的源代码。

    **第一遍汇编是用于确定所有的代码与数据的尺寸大小，这样的话，在第二遍产生代码的时候，就可以知道代码引用的所有符号地址**。所以，有一件事NASM 不能处理，那就是一段代码的尺寸依赖于另一个符号值，而这个符号又在这段代码的后面被声明。比如：

    ```asm
    times   (label-$)     db  0 ; 在第一遍的时候不知道 label 的值，所以会报错
    label:  db  'Where am I?'
    ```

    但是很奇怪，`times 510 - ($-$$) db 0` 这样就可以，说明 `$`和`$$`是第一遍的时候确定的？
    那既然这样的话，为什么 `times (0x7C00+510 - $) db 0` 又是不行呢？
    `times (0x1FE - $) db 0` 也不行
    有在网上看到说 `$` 是不确定的，`$ - $$` 是确定的

4. 每个 SECTION 有什么作用呢？

    目前只知道每个 SECTION 会在内存分配的时候进行 **4 Bytes 对齐**
    如下图：每个 SECTION 里定义一个字节，但是在内存里分配了 4字节。（可能是因为跟CPU 是32bit 有关？）

    ![看不到图时科学问题](https://raw.githubusercontent.com/yiyah/Picture_Material/master/20220124215956.png)

5. `org` 的作用

    告诉编译器，我的程序的地址从这里开始。

    比如 `org 0x100` 第一条指令的地址在 编译器 的眼中就是 0x100

6. `BITS 16` 和 `BITS 32`

    这两个其实在编译的时候会决定 机器码，比如同是 `mov ax,cs`
    在 32Bit code 里，可能给你汇编成 `mov eax,cs`

    所以，不同 Bit 的 code 对应的机器指令应该是不一样的，当然这只是其中一个不同点，比如地址？数据长度？

7. `ALIGN 16` 和 `ALIGN 32`
   字节对齐，16 Bytes 对齐 和 32 Bytes 对齐，是指 指令/数据的地址 对齐这么多个字节。

8. 在思考一个问题：CPU 取址的时候 是如何知道指令长度呢？
   其实是汇编成 机器码 的时候，这个机器码固定搭配后面跟多少字节的数据了，CPU 读到这个机器码就已经知道后面的数据长度了。所以 CPU 就能正确的执行指令。然后 IP 根据这次的长度自动加上对应长度，指向下一条指令。
   * 那么又有问题了，比如一条指令在最后，它恰巧不足以使这个 SECTION 进行 4Bytes 对齐，也就是说这条指令后面会 补上 0。CPU 又怎么知道取多少长度了？和之前讲的一样，机器码固定搭配后面的字节 size 了。
   * **还有个问题没想明白**：就是如何知道机器码的长度了？比如右边注释是汇编后的机器码
     CPU 是如何知道读取 `B8` 和 `66B8` 呢？

        ```asm
        [BITS   16]
        mov ax,32       ; B82000

        [BITS   32]
        mov ax,32       ; 66B82000
        ```

## 参考

1. [ORG](https://baike.baidu.com/item/org/9909575)
2. [[Intel汇编-NASM]基本语法](https://www.it610.com/article/5041939.htm)
3. [30天自制操作系统.pdf等](https://pan.baidu.com/s/16LPZC#list/path=%2F)（里面有nasm中文手册，从鸠摩搜书找到的）
