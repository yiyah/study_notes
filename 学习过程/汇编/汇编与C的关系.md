# 汇编与 C 的关系

* 通过在 main() 里写很多一样的语句，或者直接输出 main 的地址，我们可以找到 main 的地址在 1FA 处
* c link 和 汇编的 link 的区别

  * 汇编 link 后的文件比较小
  * c 语言的 link 的 main 函数在 1FA，而汇编 link 后的 main 函数在 0.
  * C0S.OBJ: 如果把 main() 换成其他再去编译，会提示：`link error: Undefined symbol '_main' in module C0S`

    * 这个 COS.obj 就是通过 c link 在 main() 函数前的代码，作用是设置 c 语言环境。

* 程序的返回值就是 ax 的值。（在最后会把 ax 给到一个地址中）
* 为什么 c语言 的指针是一样的字节？
  * 想一想汇编中的直接定址表，定义了变量后，定义一个定址表来表示这个变量的地址都是 `dw OFFSET xxx`, 所以地址都是一样的字节。
  * `char*` 看成是 偏移地址

* 关于数组和汇编里的定址表

  在 c 里，int 型的数组每次加1（a[0], a[1]）在内存上 或者说 对应到汇编上都是 加2。为了保持 读取 的一致性。

* 全局变量 和 字符串 存在不同的内存中（都在 ds 段），局部变量放在 ss:sp
* 变量的定义位置

  * 局部变量：在 栈 中先定义的变量在低地址。如：int a, b, c; 对应 [BP - 6], [BP - 4], [BP - 2]
  * 参数：参数从右边开始 push
  * **因为调用function顺序是**：传参 --> call fun --> 处理子函数的局部变量
    传参的过程是： push 操作，最右的参数先 push
    call fun 的过程是：push ip --> push BP 的操作 --> mov bp,sp;
    处理子函数的局部变量的过程是： sub sp,xx; --> push 变量
    所以 [BP - 2] 是获取局部变量; [BP + 4] 是获取参数。（BP 至少要 +4 才能获取到参数）
  * 再举一个例子

    ```c
    void show(int, int, ...);  // ... 表示参数个数未知
    main()
    {
        int a, b, c;
        a = 0xA1;
        b = 0xA2;
        c = 0xA3;

        show(8,2,'a','b','c','d','e','f','g','h');  // 10 个参数
    }

    void show(int count, int color, ...)
    {
        // 进来这里的时候已经 push 10个参数 --> push ip --> push bp --> mov bp,sp
        int d;
        for(d = 0;d != count; d++)
        {
            *(char far*)(0xB8000000 + 160*10 + 30*2 + d + d) = *((int*)(_BP+8+d+d));  // +8 是因为跳过bp,ip, 前两个参数。直接拿到 'a'；为什么要 int* 呢？因为参数是通过 push 进来的，一次是两个字节，所以需要 int* 转换一下地址长度; 最后取内容 放到显存
            *(char far*)(0xB8000000 + 160*10 + 30*2 + 1 + d + d) = color;
        }
    }
    ```

## c 的参数内存分配

* 关于在子函数里改 传进来的变量 的问题

    要想在 子函数 里可以改到传进来的变量，就必须是传进来变量地址，因为要改变的是这个地址指向的内容！这样才可以改变传进来的变量。

```c
main()
{
  char* a = "123";    // si = 0194
  char* b = "abc";    // di = 0198
  char* tmp = a;      // [bp - 4] = si
  char* c = 0;        // [bp - 2] = 0, 如果没有初始化这个变量 或者 没有用到 就不会分配内存
  a = b;              // si = di
  b = tmp;            // di = [bp - 4]
  printf("%s\n",a);
  printf("%s\n",b);

  // 经实验：就算在增加 字符串 都不会用寄存器来保存，而是用 栈
}
```

```c
void f(char* a,char* b);

main()
{
  char* a = "123";    // si = 0194
  char* b = "abc";    // di = 0198
  f(a,b);
}

void f(char* a,char* b)  // 多加一个参数也会 push
{
  char* tmp = a;      // si = [bp + 4] ; ax = [bp + 6]
  a = b;              // [bp + 4] = ax
  b = tmp;            // [bp + 6] = si
  // 操作的都是 [bp + 4] 和 [bp + 6] 所以程序返回 变量就没有了
}

```

## 不同语言间的区别

* 其实就是内存模型的不同，各个语言之间怎么安排数据，怎么回收数据。
* 面向对象中的类高明在于 扩大了数据类型的概念，本来表示的时内存的长度，扩大成有什么数据，有什么方法。
  类中定义的方法都是针对 这个类定义的对象，就算有无数个对象都是用这套方法来操作这段内存。
  假如(在 java 中) `Person t = new student();` 这个 t 能点出什么来，看的是 数据类型，但是具体的方法如果被子类 student 覆盖了，就会调用子类的。

## 字节对齐

从寄存器上看是提高了效率，为什么？
比如 `rep movsb` 要移动 99 个字节，一般情况用 `movsb` 要移动 99 次，但是现在你手动补一下最后一个字节变成 100字节，用 `movsw` 只需要移动 50 次就可以了。

## API

就是别人写好的程序，一些基础的功能，比如 系统的API，windows的，Linux的，
而 java 是在虚拟机上提供 API，为什么呢？是为了消除系统与系统之间的差别。

## 参考

1. [C语言函数参数入栈顺序](https://blog.csdn.net/jianmai3616/article/details/108127430)
